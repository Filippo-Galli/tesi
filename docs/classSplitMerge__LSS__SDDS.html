<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Docs: SplitMerge_LSS_SDDS Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://cdn.jsdelivr.net/gh/jothepro/doxygen-awesome-css@v2.3.4/doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="https://cdn.jsdelivr.net/gh/jothepro/doxygen-awesome-css@v2.3.4/doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="https://cdn.jsdelivr.net/gh/jothepro/doxygen-awesome-css@v2.3.4/doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classSplitMerge__LSS__SDDS.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSplitMerge__LSS__SDDS-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SplitMerge_LSS_SDDS Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Locality Sensitive Sampling (LSS) with SDDS Split-Merge sampler.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="splitmerge__LSS__SDDS_8hpp_source.html">splitmerge_LSS_SDDS.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SplitMerge_LSS_SDDS:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSplitMerge__LSS__SDDS.png" usemap="#SplitMerge_5FLSS_5FSDDS_map" alt=""/>
  <map id="SplitMerge_5FLSS_5FSDDS_map" name="SplitMerge_5FLSS_5FSDDS_map">
<area href="classSampler.html" title="Abstract base class for MCMC sampler implementations." alt="Sampler" shape="rect" coords="0,0,144,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c36977c3b8be71fbfbfe3056f9630b3" id="r_a0c36977c3b8be71fbfbfe3056f9630b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c36977c3b8be71fbfbfe3056f9630b3">SplitMerge_LSS_SDDS</a> (<a class="el" href="classData.html">Data</a> &amp;d, <a class="el" href="structParams.html">Params</a> &amp;p, <a class="el" href="classLikelihood.html">Likelihood</a> &amp;l, <a class="el" href="classProcess.html">Process</a> &amp;pr, bool <a class="el" href="#aa07752d43ab1d5480b76ac2642f838e7">shuffle</a>)</td></tr>
<tr class="memdesc:a0c36977c3b8be71fbfbfe3056f9630b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for LSS-SDDS (Locality Sensitive Sampling with Smart-split, Dumb-merge, Dumb-split, Smart-merge) Split-Merge sampler.  <br /></td></tr>
<tr class="separator:a0c36977c3b8be71fbfbfe3056f9630b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fca16f4078d67f6c77a09853025f60" id="r_ac6fca16f4078d67f6c77a09853025f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6fca16f4078d67f6c77a09853025f60">step</a> () override</td></tr>
<tr class="memdesc:ac6fca16f4078d67f6c77a09853025f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one iteration of the LSS-SDDS Split-Merge algorithm.  <br /></td></tr>
<tr class="separator:ac6fca16f4078d67f6c77a09853025f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271b4214f6ba3814da718e85bca776d6" id="r_a271b4214f6ba3814da718e85bca776d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a271b4214f6ba3814da718e85bca776d6">get_accepted_split</a> () const</td></tr>
<tr class="memdesc:a271b4214f6ba3814da718e85bca776d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of accepted split moves for diagnostics.  <br /></td></tr>
<tr class="separator:a271b4214f6ba3814da718e85bca776d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9edf6e0e86e664472b165867db19dc0" id="r_ab9edf6e0e86e664472b165867db19dc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9edf6e0e86e664472b165867db19dc0">get_accepted_merge</a> () const</td></tr>
<tr class="memdesc:ab9edf6e0e86e664472b165867db19dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of accepted merge moves for diagnostics.  <br /></td></tr>
<tr class="separator:ab9edf6e0e86e664472b165867db19dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa082ef1bfe00f1ab1b79dd4f1d5095c0" id="r_aa082ef1bfe00f1ab1b79dd4f1d5095c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa082ef1bfe00f1ab1b79dd4f1d5095c0">get_accepted_shuffle</a> () const</td></tr>
<tr class="memdesc:aa082ef1bfe00f1ab1b79dd4f1d5095c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of accepted shuffle moves for diagnostics.  <br /></td></tr>
<tr class="separator:aa082ef1bfe00f1ab1b79dd4f1d5095c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSampler"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classSampler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSampler.html">Sampler</a></td></tr>
<tr class="memitem:a4800cc1f9d2718968f5957ca99eee5b1 inherit pub_methods_classSampler" id="r_a4800cc1f9d2718968f5957ca99eee5b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#a4800cc1f9d2718968f5957ca99eee5b1">Sampler</a> (<a class="el" href="classData.html">Data</a> &amp;d, const <a class="el" href="structParams.html">Params</a> &amp;p, const <a class="el" href="classLikelihood.html">Likelihood</a> &amp;l, <a class="el" href="classProcess.html">Process</a> &amp;pr)</td></tr>
<tr class="memdesc:a4800cc1f9d2718968f5957ca99eee5b1 inherit pub_methods_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing sampler with required components.  <br /></td></tr>
<tr class="separator:a4800cc1f9d2718968f5957ca99eee5b1 inherit pub_methods_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211a2f7cb64b2adf3a8c66f92abf8f7d inherit pub_methods_classSampler" id="r_a211a2f7cb64b2adf3a8c66f92abf8f7d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#a211a2f7cb64b2adf3a8c66f92abf8f7d">~Sampler</a> ()=default</td></tr>
<tr class="memdesc:a211a2f7cb64b2adf3a8c66f92abf8f7d inherit pub_methods_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for proper cleanup of derived classes.  <br /></td></tr>
<tr class="separator:a211a2f7cb64b2adf3a8c66f92abf8f7d inherit pub_methods_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9887cb056c346c7aed94db4f25b1122a" id="r_a9887cb056c346c7aed94db4f25b1122a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9887cb056c346c7aed94db4f25b1122a">choose_indeces</a> (bool similarity=false)</td></tr>
<tr class="memdesc:a9887cb056c346c7aed94db4f25b1122a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly select two observations for split-merge proposal.  <br /></td></tr>
<tr class="separator:a9887cb056c346c7aed94db4f25b1122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cc367501cc94c64ce76ab2eaf9395f" id="r_a96cc367501cc94c64ce76ab2eaf9395f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96cc367501cc94c64ce76ab2eaf9395f">choose_clusters_shuffle</a> ()</td></tr>
<tr class="memdesc:a96cc367501cc94c64ce76ab2eaf9395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select clusters for shuffle move.  <br /></td></tr>
<tr class="separator:a96cc367501cc94c64ce76ab2eaf9395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62485d23e3d3c5266fa70b7c055e673c" id="r_a62485d23e3d3c5266fa70b7c055e673c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62485d23e3d3c5266fa70b7c055e673c">sequential_allocation</a> (int iterations, bool only_probabilities=false, bool sequential=true)</td></tr>
<tr class="memdesc:a62485d23e3d3c5266fa70b7c055e673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate proposal state via sequential allocation.  <br /></td></tr>
<tr class="separator:a62485d23e3d3c5266fa70b7c055e673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff849ae709df7ffeff92f39bed994ce1" id="r_aff849ae709df7ffeff92f39bed994ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff849ae709df7ffeff92f39bed994ce1">smart_split_move</a> ()</td></tr>
<tr class="memdesc:aff849ae709df7ffeff92f39bed994ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a smart split move using sequential allocation.  <br /></td></tr>
<tr class="separator:aff849ae709df7ffeff92f39bed994ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262468ac51cfdd1e45f82417f91f5864" id="r_a262468ac51cfdd1e45f82417f91f5864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a262468ac51cfdd1e45f82417f91f5864">dumb_split_move</a> ()</td></tr>
<tr class="memdesc:a262468ac51cfdd1e45f82417f91f5864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a dumb split move with random allocation.  <br /></td></tr>
<tr class="separator:a262468ac51cfdd1e45f82417f91f5864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1a640715782e4cf48f15489e7e4624" id="r_a2c1a640715782e4cf48f15489e7e4624"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1a640715782e4cf48f15489e7e4624">compute_acceptance_ratio_split</a> (double likelihood_old_cluster)</td></tr>
<tr class="memdesc:a2c1a640715782e4cf48f15489e7e4624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute acceptance ratio for LSS split move.  <br /></td></tr>
<tr class="separator:a2c1a640715782e4cf48f15489e7e4624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6145f05bccec4fe241ba11c00acf05" id="r_a5f6145f05bccec4fe241ba11c00acf05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f6145f05bccec4fe241ba11c00acf05">smart_merge_move</a> ()</td></tr>
<tr class="memdesc:a5f6145f05bccec4fe241ba11c00acf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a smart merge move using sequential allocation.  <br /></td></tr>
<tr class="separator:a5f6145f05bccec4fe241ba11c00acf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b905d39d9714364a859dfb8f23d5690" id="r_a5b905d39d9714364a859dfb8f23d5690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b905d39d9714364a859dfb8f23d5690">dumb_merge_move</a> ()</td></tr>
<tr class="memdesc:a5b905d39d9714364a859dfb8f23d5690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a dumb merge move with direct merging.  <br /></td></tr>
<tr class="separator:a5b905d39d9714364a859dfb8f23d5690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4348f50180fe57df8d86a497df90acd" id="r_aa4348f50180fe57df8d86a497df90acd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4348f50180fe57df8d86a497df90acd">compute_acceptance_ratio_merge</a> (double likelihood_old_ci, double likelihood_old_cj)</td></tr>
<tr class="memdesc:aa4348f50180fe57df8d86a497df90acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute acceptance ratio for LSS merge move.  <br /></td></tr>
<tr class="separator:aa4348f50180fe57df8d86a497df90acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07752d43ab1d5480b76ac2642f838e7" id="r_aa07752d43ab1d5480b76ac2642f838e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa07752d43ab1d5480b76ac2642f838e7">shuffle</a> ()</td></tr>
<tr class="memdesc:aa07752d43ab1d5480b76ac2642f838e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a shuffle move using LSS.  <br /></td></tr>
<tr class="separator:aa07752d43ab1d5480b76ac2642f838e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75d2bca86a931352bc5e11793adfae" id="r_a5f75d2bca86a931352bc5e11793adfae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f75d2bca86a931352bc5e11793adfae">compute_acceptance_ratio_shuffle</a> (double likelihood_old_ci, double likelihood_old_cj, int old_ci_size, int old_cj_size)</td></tr>
<tr class="memdesc:a5f75d2bca86a931352bc5e11793adfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute acceptance ratio for LSS shuffle move.  <br /></td></tr>
<tr class="separator:a5f75d2bca86a931352bc5e11793adfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9f4244224661c3cca30e8c2d4f6f035a" id="r_a9f4244224661c3cca30e8c2d4f6f035a"><td class="memItemLeft" align="right" valign="top">std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4244224661c3cca30e8c2d4f6f035a">gen</a></td></tr>
<tr class="memdesc:a9f4244224661c3cca30e8c2d4f6f035a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mersenne Twister random number generator for sampling operations.  <br /></td></tr>
<tr class="separator:a9f4244224661c3cca30e8c2d4f6f035a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7e28f5bbaa1f121c422f5674bfc66d" id="r_a5b7e28f5bbaa1f121c422f5674bfc66d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b7e28f5bbaa1f121c422f5674bfc66d">idx_i</a></td></tr>
<tr class="memdesc:a5b7e28f5bbaa1f121c422f5674bfc66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first randomly chosen observation.  <br /></td></tr>
<tr class="separator:a5b7e28f5bbaa1f121c422f5674bfc66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78a6b05561a6fd865da7ffc8fc418e6" id="r_ac78a6b05561a6fd865da7ffc8fc418e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac78a6b05561a6fd865da7ffc8fc418e6">idx_j</a></td></tr>
<tr class="memdesc:ac78a6b05561a6fd865da7ffc8fc418e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of second randomly chosen observation.  <br /></td></tr>
<tr class="separator:ac78a6b05561a6fd865da7ffc8fc418e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdf197086c8f888e0debf7bb39da56" id="r_a0ecdf197086c8f888e0debf7bb39da56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecdf197086c8f888e0debf7bb39da56">ci</a></td></tr>
<tr class="memdesc:a0ecdf197086c8f888e0debf7bb39da56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster assignment of first observation.  <br /></td></tr>
<tr class="separator:a0ecdf197086c8f888e0debf7bb39da56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5021d8461d6120edfc5aeb8e5cdb0c" id="r_acc5021d8461d6120edfc5aeb8e5cdb0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc5021d8461d6120edfc5aeb8e5cdb0c">cj</a></td></tr>
<tr class="memdesc:acc5021d8461d6120edfc5aeb8e5cdb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster assignment of second observation.  <br /></td></tr>
<tr class="separator:acc5021d8461d6120edfc5aeb8e5cdb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa067403728ed88f2b18980e4d0bb0379" id="r_aa067403728ed88f2b18980e4d0bb0379"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa067403728ed88f2b18980e4d0bb0379">shuffle_bool</a> = false</td></tr>
<tr class="memdesc:aa067403728ed88f2b18980e4d0bb0379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to enable shuffle moves (Mena and Martinez, 2014)  <br /></td></tr>
<tr class="separator:aa067403728ed88f2b18980e4d0bb0379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a553a998dad40546a0efddb30a19eca" id="r_a8a553a998dad40546a0efddb30a19eca"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a553a998dad40546a0efddb30a19eca">launch_state</a></td></tr>
<tr class="memdesc:a8a553a998dad40546a0efddb30a19eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch state for sequential allocation.  <br /></td></tr>
<tr class="separator:a8a553a998dad40546a0efddb30a19eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89d3b1669dc604e8eacb2ee938a93a0" id="r_ab89d3b1669dc604e8eacb2ee938a93a0"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab89d3b1669dc604e8eacb2ee938a93a0">S</a></td></tr>
<tr class="memdesc:ab89d3b1669dc604e8eacb2ee938a93a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of observations in clusters ci and cj.  <br /></td></tr>
<tr class="separator:ab89d3b1669dc604e8eacb2ee938a93a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415513c7aa6969479e7c4eb3021203d5" id="r_a415513c7aa6969479e7c4eb3021203d5"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415513c7aa6969479e7c4eb3021203d5">original_allocations</a></td></tr>
<tr class="memdesc:a415513c7aa6969479e7c4eb3021203d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original cluster assignments before move proposal.  <br /></td></tr>
<tr class="separator:a415513c7aa6969479e7c4eb3021203d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11d1391d015b667789491845f9a95e1" id="r_ae11d1391d015b667789491845f9a95e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae11d1391d015b667789491845f9a95e1">log_split_gibbs_prob</a> = 0</td></tr>
<tr class="memdesc:ae11d1391d015b667789491845f9a95e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log probability of generating current state via sequential allocation (split direction)  <br /></td></tr>
<tr class="separator:ae11d1391d015b667789491845f9a95e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada77f2fce6d6778a9829447a663bf3c8" id="r_ada77f2fce6d6778a9829447a663bf3c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada77f2fce6d6778a9829447a663bf3c8">log_merge_gibbs_prob</a> = 0</td></tr>
<tr class="memdesc:ada77f2fce6d6778a9829447a663bf3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log probability of generating current state via sequential allocation (merge direction)  <br /></td></tr>
<tr class="separator:ada77f2fce6d6778a9829447a663bf3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5592ec0b6838aa6c33c70a9943df5af7" id="r_a5592ec0b6838aa6c33c70a9943df5af7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5592ec0b6838aa6c33c70a9943df5af7">accepted_split</a> = 0</td></tr>
<tr class="separator:a5592ec0b6838aa6c33c70a9943df5af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e947266ef985a35f4ef446def9e42e" id="r_a39e947266ef985a35f4ef446def9e42e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e947266ef985a35f4ef446def9e42e">accepted_merge</a> = 0</td></tr>
<tr class="separator:a39e947266ef985a35f4ef446def9e42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50b9b7fcb943ede91cf41db39a17ed1" id="r_ac50b9b7fcb943ede91cf41db39a17ed1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac50b9b7fcb943ede91cf41db39a17ed1">accepted_shuffle</a> = 0</td></tr>
<tr class="separator:ac50b9b7fcb943ede91cf41db39a17ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classSampler"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classSampler')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSampler.html">Sampler</a></td></tr>
<tr class="memitem:a82728aa82b611766bc21cbfbb04e83b5 inherit pro_attribs_classSampler" id="r_a82728aa82b611766bc21cbfbb04e83b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classData.html">Data</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#a82728aa82b611766bc21cbfbb04e83b5">data</a></td></tr>
<tr class="memdesc:a82728aa82b611766bc21cbfbb04e83b5 inherit pro_attribs_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the data object containing observations and current allocations.  <br /></td></tr>
<tr class="separator:a82728aa82b611766bc21cbfbb04e83b5 inherit pro_attribs_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d788501df27a3490c27085e5c6a218 inherit pro_attribs_classSampler" id="r_a82d788501df27a3490c27085e5c6a218"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structParams.html">Params</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#a82d788501df27a3490c27085e5c6a218">params</a></td></tr>
<tr class="memdesc:a82d788501df27a3490c27085e5c6a218 inherit pro_attribs_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the parameters object containing model hyperparameters and MCMC settings.  <br /></td></tr>
<tr class="separator:a82d788501df27a3490c27085e5c6a218 inherit pro_attribs_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1572ed0ff1a7ace0f1c6b60954200d8c inherit pro_attribs_classSampler" id="r_a1572ed0ff1a7ace0f1c6b60954200d8c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLikelihood.html">Likelihood</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#a1572ed0ff1a7ace0f1c6b60954200d8c">likelihood</a></td></tr>
<tr class="memdesc:a1572ed0ff1a7ace0f1c6b60954200d8c inherit pro_attribs_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the likelihood computation object for evaluating cluster assignments.  <br /></td></tr>
<tr class="separator:a1572ed0ff1a7ace0f1c6b60954200d8c inherit pro_attribs_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec54ff9fe8f22c8514496d6f3b998d0 inherit pro_attribs_classSampler" id="r_a8ec54ff9fe8f22c8514496d6f3b998d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classProcess.html">Process</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#a8ec54ff9fe8f22c8514496d6f3b998d0">process</a></td></tr>
<tr class="memdesc:a8ec54ff9fe8f22c8514496d6f3b998d0 inherit pro_attribs_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the stochastic process object (<a class="el" href="classDP.html" title="Dirichlet Process class for Bayesian nonparametric clustering.">DP</a>, <a class="el" href="classNGGP.html" title="Normalized Generalized Gamma Process class for Bayesian nonparametric clustering.">NGGP</a>, <a class="el" href="classDPW.html" title="Dirichlet Process with spatial Weights class for spatially-aware Bayesian nonparametric clustering.">DPW</a>, <a class="el" href="classNGGPW.html" title="Normalized Generalized Gamma Process with spatial Weights class for spatially-aware Bayesian nonparam...">NGGPW</a>)  <br /></td></tr>
<tr class="separator:a8ec54ff9fe8f22c8514496d6f3b998d0 inherit pro_attribs_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec9d161c1e486904e6d2869890c4be3 inherit pro_attribs_classSampler" id="r_abec9d161c1e486904e6d2869890c4be3"><td class="memItemLeft" align="right" valign="top">std::random_device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSampler.html#abec9d161c1e486904e6d2869890c4be3">rd</a></td></tr>
<tr class="memdesc:abec9d161c1e486904e6d2869890c4be3 inherit pro_attribs_classSampler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random device for generating random numbers across sampling algorithms.  <br /></td></tr>
<tr class="separator:abec9d161c1e486904e6d2869890c4be3 inherit pro_attribs_classSampler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Locality Sensitive Sampling (LSS) with SDDS Split-Merge sampler. </p>
<p>This class implements the LSS Split-Merge algorithm with SDDS (Smart-split, Dumb-merge, Dumb-split, Smart-merge), a variant of the split-merge sampler that uses locality sensitive sampling to select anchor points based on similarity/dissimilarity information. The SDDS strategy adaptively chooses between smart (sequential allocation) and dumb (simple random) proposals to balance computational cost with proposal quality:</p><ul>
<li>When dissimilar points are selected: Smart split + Dumb merge</li>
<li>When similar points are selected: Dumb split + Smart merge This improves mixing efficiency while maintaining computational tractability.</li>
</ul>
<p>Key differences from standard Split-Merge:</p><ul>
<li><b>Locality Sensitive Sampling</b>: Anchor points are selected based on similarity/distance</li>
<li><b>SDDS Strategy</b>: Adaptive smart/dumb pairing based on point similarity<ul>
<li>Dissimilar points → Smart split (sequential allocation) + Dumb merge (direct)</li>
<li>Similar points → Dumb split (random) + Smart merge (sequential allocation)</li>
</ul>
</li>
<li><b>Sequential Allocation</b>: Used in "smart" moves for intelligent proposal generation</li>
<li><b>Efficient Computation</b>: Balances computational cost with mixing quality</li>
<li><b>Maintained Ergodicity</b>: Preserves theoretical properties of split-merge</li>
</ul>
<p>The algorithm maintains the same three types of moves (split, merge, shuffle) but uses locality sensitive sampling for anchor point selection and adaptively applies sequential allocation based on the SDDS strategy.</p>
<dl class="section note"><dt>Note</dt><dd>References:<ul>
<li>Luo, C., Shrivastava, A. (2018). "Scaling-up Split-Merge MCMC with
  Locality Sensitive Sampling (LSS)"</li>
<li>Dahl, D. B. and Newcomb, S. (2022). "Sequentially allocated merge-split
  samplers for conjugate Bayesian nonparametric models"</li>
<li>Martinez, A. F. and Mena, R. H. (2014). "On a Nonparametric Change Point
  Detection Model in Markovian Regimes"</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSampler.html" title="Abstract base class for MCMC sampler implementations.">Sampler</a>, <a class="el" href="classSplitMerge.html" title="Split-Merge sampler for Bayesian nonparametric mixture models.">SplitMerge</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c36977c3b8be71fbfbfe3056f9630b3" name="a0c36977c3b8be71fbfbfe3056f9630b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c36977c3b8be71fbfbfe3056f9630b3">&#9670;&#160;</a></span>SplitMerge_LSS_SDDS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SplitMerge_LSS_SDDS::SplitMerge_LSS_SDDS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classData.html">Data</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParams.html">Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLikelihood.html">Likelihood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classProcess.html">Process</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shuffle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for LSS-SDDS (Locality Sensitive Sampling with Smart-split, Dumb-merge, Dumb-split, Smart-merge) Split-Merge sampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Reference to <a class="el" href="classData.html" title="Manages distance matrices and cluster allocations for points.">Data</a> object containing observations </td></tr>
    <tr><td class="paramname">p</td><td>Reference to <a class="el" href="structParams.html" title="Structure containing all parameters needed for the NGGP (Normalized Generalized Gamma Process) and DP...">Params</a> object with hyperparameters (including distance matrix D) </td></tr>
    <tr><td class="paramname">l</td><td>Reference to <a class="el" href="classLikelihood.html" title="Computes log-likelihood for clusters based on distance-based cohesion and repulsion.">Likelihood</a> object for probability computations </td></tr>
    <tr><td class="paramname">pr</td><td>Reference to <a class="el" href="classProcess.html" title="Abstract base class for Bayesian nonparametric processes.">Process</a> object defining the prior </td></tr>
    <tr><td class="paramname">shuffle</td><td>Flag to enable shuffle moves in addition to split-merge</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the LSS-SDDS Split-Merge sampler, which uses:</p><ul>
<li>Locality sensitive sampling for anchor point selection</li>
<li>SDDS strategy (Smart-split, Dumb-merge, Dumb-split, Smart-merge) that adaptively pairs smart and dumb moves based on point similarity</li>
<li>Sequential allocation for "smart" proposal generation</li>
<li>Simple random allocation for "dumb" proposals This sampler provides computational advantages for large datasets by intelligently balancing computational cost with proposal quality. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a96cc367501cc94c64ce76ab2eaf9395f" name="a96cc367501cc94c64ce76ab2eaf9395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cc367501cc94c64ce76ab2eaf9395f">&#9670;&#160;</a></span>choose_clusters_shuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::choose_clusters_shuffle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select clusters for shuffle move. </p>
<p>Determines cluster assignments and prepares for redistribution between two existing clusters. </p>
<p>Select two distinct clusters and anchor points for shuffle move</p>
<p>For shuffle moves:</p><ol type="1">
<li>Returns early if fewer than 2 clusters exist</li>
<li>Uniformly selects two distinct clusters ci and cj</li>
<li>Uniformly selects random point idx_i from cluster ci</li>
<li>Uniformly selects random point idx_j from cluster cj</li>
<li>Stores original allocations for potential rejection</li>
<li>Prepares launch_state and S vectors containing all points from ci and cj (excluding idx_i and idx_j which serve as anchors)</li>
</ol>
<p>Unlike <a class="el" href="#a9887cb056c346c7aed94db4f25b1122a" title="Randomly select two observations for split-merge proposal.">choose_indeces()</a>, this method doesn't use locality sensitive sampling since shuffle moves operate on existing cluster structure.</p>

</div>
</div>
<a id="a9887cb056c346c7aed94db4f25b1122a" name="a9887cb056c346c7aed94db4f25b1122a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9887cb056c346c7aed94db4f25b1122a">&#9670;&#160;</a></span>choose_indeces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::choose_indeces </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>similarity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly select two observations for split-merge proposal. </p>
<p>Samples two distinct observation indices using locality sensitive sampling. When similarity=false, selects dissimilar points (for split moves). When similarity=true, selects similar points (for merge moves). The first point is selected uniformly, and the second is selected based on distance weights from the first point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">similarity</td><td>If true, select similar points; if false, select dissimilar points </td></tr>
  </table>
  </dd>
</dl>
<p>Select two distinct data points using locality sensitive sampling</p>
<p>First selects idx_i uniformly at random. Then selects idx_j based on distance from idx_i:</p><ul>
<li>If similarity=true: weights proportional to distance (prefers similar points)</li>
<li>If similarity=false: weights proportional to 1/distance (prefers dissimilar points)</li>
</ul>
<p>After selection, identifies clusters ci and cj, and prepares launch_state and S vectors containing all other points from these clusters for the split-merge operation. The vectors are shuffled to ensure random processing order.</p>

</div>
</div>
<a id="aa4348f50180fe57df8d86a497df90acd" name="aa4348f50180fe57df8d86a497df90acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4348f50180fe57df8d86a497df90acd">&#9670;&#160;</a></span>compute_acceptance_ratio_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SplitMerge_LSS_SDDS::compute_acceptance_ratio_merge </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>likelihood_old_ci</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>likelihood_old_cj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute acceptance ratio for LSS merge move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">likelihood_old_ci</td><td>Log-likelihood of first original cluster ci before merge </td></tr>
    <tr><td class="paramname">likelihood_old_cj</td><td>Log-likelihood of second original cluster cj before merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log acceptance ratio for the merge proposal</dd></dl>
<p>Computes log acceptance ratio as: log(α) = log(prior_ratio) + log(likelihood_ratio) + log(proposal_ratio) where:</p><ul>
<li>prior_ratio accounts for cluster size changes</li>
<li>likelihood_ratio = L(ci_merged) - L(ci_old) - L(cj_old)</li>
<li>proposal_ratio is log_merge_gibbs_prob (0 for dumb merge) </li>
</ul>
<p>Compute the log acceptance ratio for a merge move</p>
<p>Computes log(α) = log(prior_ratio) + log(likelihood_ratio) + log(proposal_ratio)</p><ul>
<li>Prior ratio: accounts for change from two clusters to one</li>
<li><a class="el" href="classLikelihood.html" title="Computes log-likelihood for clusters based on distance-based cohesion and repulsion.">Likelihood</a> ratio: L(merged_ci) - L(old_ci) - L(old_cj)</li>
<li>Proposal ratio: log_merge_gibbs_prob (probability of reverse split move) Note: For dumb merge, log_merge_gibbs_prob = 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">likelihood_old_ci</td><td>Log-likelihood of cluster ci before merge </td></tr>
    <tr><td class="paramname">likelihood_old_cj</td><td>Log-likelihood of cluster cj before merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log acceptance ratio for the merge move</dd></dl>

</div>
</div>
<a id="a5f75d2bca86a931352bc5e11793adfae" name="a5f75d2bca86a931352bc5e11793adfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75d2bca86a931352bc5e11793adfae">&#9670;&#160;</a></span>compute_acceptance_ratio_shuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SplitMerge_LSS_SDDS::compute_acceptance_ratio_shuffle </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>likelihood_old_ci</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>likelihood_old_cj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>old_ci_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>old_cj_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute acceptance ratio for LSS shuffle move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">likelihood_old_ci</td><td>Log-likelihood of first cluster ci before shuffle </td></tr>
    <tr><td class="paramname">likelihood_old_cj</td><td>Log-likelihood of second cluster cj before shuffle </td></tr>
    <tr><td class="paramname">old_ci_size</td><td>Size of cluster ci before shuffle </td></tr>
    <tr><td class="paramname">old_cj_size</td><td>Size of cluster cj before shuffle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log acceptance ratio for the shuffle proposal</dd></dl>
<p>Computes log acceptance ratio as: log(α) = log(prior_ratio) + log(likelihood_ratio) + log(proposal_ratio) where:</p><ul>
<li>prior_ratio accounts for cluster size changes in shuffle</li>
<li>likelihood_ratio = L(ci_new) + L(cj_new) - L(ci_old) - L(cj_old)</li>
<li>proposal_ratio = log_merge_gibbs_prob - log_split_gibbs_prob </li>
</ul>
<p>Compute the log acceptance ratio for a shuffle move</p>
<p>Computes log(α) = log(prior_ratio) + log(likelihood_ratio) + log(proposal_ratio)</p><ul>
<li>Prior ratio: accounts for cluster size changes (shuffle maintains 2 clusters)</li>
<li><a class="el" href="classLikelihood.html" title="Computes log-likelihood for clusters based on distance-based cohesion and repulsion.">Likelihood</a> ratio: L(new_ci) + L(new_cj) - L(old_ci) - L(old_cj)</li>
<li>Proposal ratio: log_merge_gibbs_prob - log_split_gibbs_prob (ratio of reverse to forward proposal probabilities)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">likelihood_old_ci</td><td>Log-likelihood of cluster ci before shuffle </td></tr>
    <tr><td class="paramname">likelihood_old_cj</td><td>Log-likelihood of cluster cj before shuffle </td></tr>
    <tr><td class="paramname">old_ci_size</td><td>Size of cluster ci before shuffle </td></tr>
    <tr><td class="paramname">old_cj_size</td><td>Size of cluster cj before shuffle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log acceptance ratio for the shuffle move</dd></dl>

</div>
</div>
<a id="a2c1a640715782e4cf48f15489e7e4624" name="a2c1a640715782e4cf48f15489e7e4624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1a640715782e4cf48f15489e7e4624">&#9670;&#160;</a></span>compute_acceptance_ratio_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SplitMerge_LSS_SDDS::compute_acceptance_ratio_split </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>likelihood_old_cluster</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute acceptance ratio for LSS split move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">likelihood_old_cluster</td><td>Log-likelihood of the original single cluster before split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log acceptance ratio for the split proposal</dd></dl>
<p>Computes log acceptance ratio as: log(α) = log(prior_ratio) + log(likelihood_ratio) - log(proposal_ratio) where:</p><ul>
<li>prior_ratio accounts for cluster size changes</li>
<li>likelihood_ratio = L(ci_new) + L(cj_new) - L(ci_old)</li>
<li>proposal_ratio is log_split_gibbs_prob (0 for dumb split) </li>
</ul>
<p>Compute the log acceptance ratio for a split move</p>
<p>Computes log(α) = log(prior_ratio) + log(likelihood_ratio) - log(proposal_ratio)</p><ul>
<li>Prior ratio: accounts for change from one cluster to two</li>
<li><a class="el" href="classLikelihood.html" title="Computes log-likelihood for clusters based on distance-based cohesion and repulsion.">Likelihood</a> ratio: L(new_ci) + L(new_cj) - L(old_ci)</li>
<li>Proposal ratio: log_split_gibbs_prob (probability of forward split path) Note: For dumb split, log_split_gibbs_prob = 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">likelihood_old_cluster</td><td>Log-likelihood of the original cluster before split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log acceptance ratio for the split move</dd></dl>

</div>
</div>
<a id="a5b905d39d9714364a859dfb8f23d5690" name="a5b905d39d9714364a859dfb8f23d5690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b905d39d9714364a859dfb8f23d5690">&#9670;&#160;</a></span>dumb_merge_move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::dumb_merge_move </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a dumb merge move with direct merging. </p>
<p>Directly merges two clusters ci and cj into one (ci) without sequential allocation. All points in cj are simply reassigned to ci. No proposal probability is computed (log_merge_gibbs_prob = 0). Faster but simpler proposal mechanism than <a class="el" href="#a5f6145f05bccec4fe241ba11c00acf05" title="Execute a smart merge move using sequential allocation.">smart_merge_move()</a>. </p>
<p>Propose a dumb merge move with direct merging</p>
<p>Simple merge without sequential allocation:</p><ol type="1">
<li>Records old cluster likelihoods</li>
<li>Sets log_merge_gibbs_prob = 0 (no proposal probability)</li>
<li>Directly assigns idx_j to ci</li>
<li>Reassigns all points from cj to ci</li>
<li>Computes acceptance ratio without proposal term</li>
<li>Accepts/rejects via Metropolis-Hastings</li>
</ol>
<p>Computationally faster than smart_merge but may have lower acceptance rates due to simpler proposal mechanism.</p>

</div>
</div>
<a id="a262468ac51cfdd1e45f82417f91f5864" name="a262468ac51cfdd1e45f82417f91f5864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262468ac51cfdd1e45f82417f91f5864">&#9670;&#160;</a></span>dumb_split_move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::dumb_split_move </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a dumb split move with random allocation. </p>
<p>Splits a cluster ci into two clusters (ci and cj) by randomly allocating points without sequential refinement. Anchor points idx_i and idx_j are placed in separate clusters, and all other points are randomly assigned to ci or cj with equal probability. No proposal probability is computed (log_split_gibbs_prob = 0). Faster but may have lower acceptance rates than <a class="el" href="#aff849ae709df7ffeff92f39bed994ce1" title="Execute a smart split move using sequential allocation.">smart_split_move()</a>. </p>
<p>Propose a dumb split move with random allocation</p>
<p>Simple split without sequential allocation refinement:</p><ol type="1">
<li>Records old single cluster likelihood</li>
<li>Sets log_split_gibbs_prob = 0 (no proposal probability)</li>
<li>Creates new cluster cj and assigns idx_j to it (idx_i remains in ci)</li>
<li>Randomly allocates other points to ci or cj with equal probability (50/50)</li>
<li>Computes acceptance ratio without proposal term</li>
<li>Accepts/rejects via Metropolis-Hastings</li>
</ol>
<p>Computationally faster than smart_split but may have lower acceptance rates due to purely random initial allocation.</p>

</div>
</div>
<a id="ab9edf6e0e86e664472b165867db19dc0" name="ab9edf6e0e86e664472b165867db19dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9edf6e0e86e664472b165867db19dc0">&#9670;&#160;</a></span>get_accepted_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::get_accepted_merge </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of accepted merge moves for diagnostics. </p>
<dl class="section return"><dt>Returns</dt><dd>Count of accepted merge moves </dd></dl>

</div>
</div>
<a id="aa082ef1bfe00f1ab1b79dd4f1d5095c0" name="aa082ef1bfe00f1ab1b79dd4f1d5095c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa082ef1bfe00f1ab1b79dd4f1d5095c0">&#9670;&#160;</a></span>get_accepted_shuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::get_accepted_shuffle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of accepted shuffle moves for diagnostics. </p>
<dl class="section return"><dt>Returns</dt><dd>Count of accepted shuffle moves </dd></dl>

</div>
</div>
<a id="a271b4214f6ba3814da718e85bca776d6" name="a271b4214f6ba3814da718e85bca776d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271b4214f6ba3814da718e85bca776d6">&#9670;&#160;</a></span>get_accepted_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::get_accepted_split </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of accepted split moves for diagnostics. </p>
<dl class="section return"><dt>Returns</dt><dd>Count of accepted split moves </dd></dl>

</div>
</div>
<a id="a62485d23e3d3c5266fa70b7c055e673c" name="a62485d23e3d3c5266fa70b7c055e673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62485d23e3d3c5266fa70b7c055e673c">&#9670;&#160;</a></span>sequential_allocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::sequential_allocation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>only_probabilities</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sequential</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate proposal state via sequential allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>Number of allocation passes to perform </td></tr>
    <tr><td class="paramname">only_probabilities</td><td>If true, only compute proposal probabilities without modifying allocations (used for computing reverse move probabilities) </td></tr>
    <tr><td class="paramname">sequential</td><td>If true, unallocate all points before sequential allocation; if false, use restricted Gibbs sampling (unallocate one at a time)</td></tr>
  </table>
  </dd>
</dl>
<p>Implements sequential allocation by processing observations one by one in random order. Each observation is allocated to cluster ci or cj based on conditional likelihood and prior probabilities. This method computes the log probability of the proposed allocation path, which is used in the acceptance ratio. </p>
<p>Perform sequential allocation or restricted Gibbs sampling on points in S</p>
<p>This function allocates points between clusters ci and cj using one of two modes:</p><ul>
<li>Sequential allocation (sequential=true): Unallocates all points in S at once, then processes them one by one, computing conditional probabilities based on current state</li>
<li>Restricted Gibbs (sequential=false): Unallocates and reallocates points one at a time</li>
</ul>
<p>For each point, computes conditional log-probabilities for assignment to ci or cj based on likelihood and prior. If only_probabilities=false, samples new assignments and accumulates log_split_gibbs_prob. If only_probabilities=true, retains original assignments and accumulates log_merge_gibbs_prob (for reverse move probability).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>Number of allocation passes to perform </td></tr>
    <tr><td class="paramname">only_probabilities</td><td>If true, compute probabilities without changing allocations </td></tr>
    <tr><td class="paramname">sequential</td><td>If true, use sequential allocation; if false, use restricted Gibbs</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07752d43ab1d5480b76ac2642f838e7" name="aa07752d43ab1d5480b76ac2642f838e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07752d43ab1d5480b76ac2642f838e7">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::shuffle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a shuffle move using LSS. </p>
<p>Redistributes observations between two existing clusters ci and cj using sequential allocation while maintaining the two-cluster structure. Computes both forward (log_merge_gibbs_prob) and reverse (log_split_gibbs_prob) proposal probabilities to ensure detailed balance. This move helps improve mixing between existing clusters. </p>
<p>Perform a shuffle move to redistribute points between two existing clusters</p>
<p>Refines allocations between clusters ci and cj while maintaining both:</p><ol type="1">
<li>Checks if at least 2 clusters exist (returns early if not)</li>
<li>Records old cluster likelihoods and sizes</li>
<li>Computes reverse proposal probability via sequential_allocation(only_probabilities=true) stored in log_merge_gibbs_prob</li>
<li>Performs sequential_allocation(only_probabilities=false) to:<ul>
<li>Reallocate points between ci and cj</li>
<li>Compute forward proposal probability in log_split_gibbs_prob</li>
</ul>
</li>
<li>Computes acceptance ratio with bidirectional proposal probabilities</li>
<li>Accepts/rejects via Metropolis-Hastings</li>
</ol>
<p>This move improves mixing by allowing refined redistribution between existing clusters without changing the total number of clusters.</p>

</div>
</div>
<a id="a5f6145f05bccec4fe241ba11c00acf05" name="a5f6145f05bccec4fe241ba11c00acf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6145f05bccec4fe241ba11c00acf05">&#9670;&#160;</a></span>smart_merge_move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::smart_merge_move </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a smart merge move using sequential allocation. </p>
<p>Merges two clusters ci and cj into one (ci) using sequential allocation to determine the final merged state. All points are initially assigned to ci, then sequential allocation computes the probability of this configuration. The proposal probability (log_merge_gibbs_prob) is included in the acceptance ratio. More accurate proposals with higher computational cost than <a class="el" href="#a5b905d39d9714364a859dfb8f23d5690" title="Execute a dumb merge move with direct merging.">dumb_merge_move()</a>. </p>
<p>Propose a smart merge move using sequential allocation</p>
<p>Merges clusters ci and cj into ci with intelligent proposal:</p><ol type="1">
<li>Records old cluster likelihoods</li>
<li>Assigns both anchor points (idx_i, idx_j) to ci</li>
<li>Initially assigns all other points to ci</li>
<li>Uses sequential_allocation(only_probabilities=true) to compute the probability of arriving at the merged configuration (for reverse split probability)</li>
<li>Computes acceptance ratio including proposal probability</li>
<li>Accepts/rejects via Metropolis-Hastings</li>
</ol>
<p>Higher computational cost than dumb_merge but better proposals through sequential allocation refinement.</p>

</div>
</div>
<a id="aff849ae709df7ffeff92f39bed994ce1" name="aff849ae709df7ffeff92f39bed994ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff849ae709df7ffeff92f39bed994ce1">&#9670;&#160;</a></span>smart_split_move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::smart_split_move </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a smart split move using sequential allocation. </p>
<p>Splits a cluster ci into two clusters (ci and cj) using sequential allocation for intelligent proposal generation. Anchor points idx_i and idx_j are placed in separate clusters, other points are randomly initialized, then refined via sequential allocation. The proposal probability is computed and included in the acceptance ratio. Provides better proposals but at higher computational cost than <a class="el" href="#a262468ac51cfdd1e45f82417f91f5864" title="Execute a dumb split move with random allocation.">dumb_split_move()</a>. </p>
<p>Propose a smart split move using sequential allocation</p>
<p>Intelligently splits cluster ci into ci and new cluster cj:</p><ol type="1">
<li>Records old single cluster likelihood</li>
<li>Creates new cluster cj and assigns idx_j to it (idx_i remains in ci)</li>
<li>Randomly initializes allocation of other points to ci or cj</li>
<li>Refines via sequential_allocation(1) which:<ul>
<li>Processes points in random order</li>
<li>Computes conditional probabilities for each assignment</li>
<li>Accumulates log_split_gibbs_prob for proposal ratio</li>
</ul>
</li>
<li>Computes acceptance ratio including proposal probability</li>
<li>Accepts/rejects via Metropolis-Hastings</li>
</ol>
<p>Higher computational cost than dumb_split but better mixing through intelligent sequential allocation.</p>

</div>
</div>
<a id="ac6fca16f4078d67f6c77a09853025f60" name="ac6fca16f4078d67f6c77a09853025f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fca16f4078d67f6c77a09853025f60">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SplitMerge_LSS_SDDS::step </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one iteration of the LSS-SDDS Split-Merge algorithm. </p>
<p>Executes one step of the LSS-SDDS Split-Merge sampler implementing the SDDS strategy (Smart-split, Dumb-merge, Dumb-split, Smart-merge):</p>
<ol type="1">
<li>Randomly choose between dissimilarity mode or similarity mode (50/50)</li>
<li>Select two anchor observations using locality sensitive sampling:<ul>
<li>Dissimilarity mode (move_type=0): select dissimilar points (weighted by 1/distance)</li>
<li>Similarity mode (move_type=1): select similar points (weighted by distance)</li>
</ul>
</li>
<li>Determine move type based on current cluster assignments:<ul>
<li>Same cluster (ci == cj): propose split move</li>
<li>Different clusters (ci != cj): propose merge move</li>
</ul>
</li>
<li>Execute appropriate move using SDDS pairing:<ul>
<li>Dissimilarity mode: <b>Smart split</b> if ci==cj, <b>Dumb merge</b> if ci!=cj</li>
<li>Similarity mode: <b>Dumb split</b> if ci==cj, <b>Smart merge</b> if ci!=cj</li>
</ul>
</li>
<li>Optionally perform shuffle move to improve mixing</li>
<li>Compute acceptance ratio and accept/reject the proposal</li>
</ol>
<p>The SDDS strategy balances computational efficiency with proposal quality by using smart (sequential allocation) moves where they matter most and dumb (simple random) moves elsewhere, while maintaining detailed balance. </p>
<p>Perform a single LSS-SDDS split-merge MCMC step</p>
<p>Implements the SDDS strategy (Smart-split, Dumb-merge, Dumb-split, Smart-merge):</p>
<ol type="1">
<li>Randomly chooses between two modes with equal probability (50/50):<ul>
<li>Mode 0 (dissimilarity): Selects dissimilar points (1/distance weighting)</li>
<li>Mode 1 (similarity): Selects similar points (distance weighting)</li>
</ul>
</li>
<li>Selects anchor points using <a class="el" href="#a9887cb056c346c7aed94db4f25b1122a" title="Randomly select two observations for split-merge proposal.">choose_indeces()</a> with appropriate similarity flag</li>
<li>Updates process state with old allocations and anchor indices</li>
<li>Determines and executes move using SDDS pairing:<ul>
<li><b>Dissimilarity mode (move_type=0):</b><ul>
<li>If ci==cj: <b><a class="el" href="#aff849ae709df7ffeff92f39bed994ce1" title="Execute a smart split move using sequential allocation.">smart_split_move()</a></b> - use sequential allocation for quality split</li>
<li>If ci!=cj: <b><a class="el" href="#a5b905d39d9714364a859dfb8f23d5690" title="Execute a dumb merge move with direct merging.">dumb_merge_move()</a></b> - use simple merge for efficiency</li>
</ul>
</li>
<li><b>Similarity mode (move_type=1):</b><ul>
<li>If ci!=cj: <b><a class="el" href="#a262468ac51cfdd1e45f82417f91f5864" title="Execute a dumb split move with random allocation.">dumb_split_move()</a></b> - use simple split for efficiency</li>
<li>If ci==cj: <b><a class="el" href="#a5f6145f05bccec4fe241ba11c00acf05" title="Execute a smart merge move using sequential allocation.">smart_merge_move()</a></b> - use sequential allocation for quality merge</li>
</ul>
</li>
</ul>
</li>
<li>Optionally performs shuffle move if shuffle_bool is enabled</li>
</ol>
<p>The SDDS strategy intelligently allocates computational resources: expensive sequential allocation is used for splits when dissimilar points are selected (where splits are likely) and for merges when similar points are selected (where merges are likely), while using simpler proposals elsewhere.</p>

<p>Implements <a class="el" href="classSampler.html#a49153313f42d53d107bfe2b2e9d83fa5">Sampler</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39e947266ef985a35f4ef446def9e42e" name="a39e947266ef985a35f4ef446def9e42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e947266ef985a35f4ef446def9e42e">&#9670;&#160;</a></span>accepted_merge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::accepted_merge = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac50b9b7fcb943ede91cf41db39a17ed1" name="ac50b9b7fcb943ede91cf41db39a17ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50b9b7fcb943ede91cf41db39a17ed1">&#9670;&#160;</a></span>accepted_shuffle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::accepted_shuffle = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5592ec0b6838aa6c33c70a9943df5af7" name="a5592ec0b6838aa6c33c70a9943df5af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5592ec0b6838aa6c33c70a9943df5af7">&#9670;&#160;</a></span>accepted_split</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::accepted_split = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ecdf197086c8f888e0debf7bb39da56" name="a0ecdf197086c8f888e0debf7bb39da56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecdf197086c8f888e0debf7bb39da56">&#9670;&#160;</a></span>ci</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::ci</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cluster assignment of first observation. </p>

</div>
</div>
<a id="acc5021d8461d6120edfc5aeb8e5cdb0c" name="acc5021d8461d6120edfc5aeb8e5cdb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5021d8461d6120edfc5aeb8e5cdb0c">&#9670;&#160;</a></span>cj</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::cj</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cluster assignment of second observation. </p>

</div>
</div>
<a id="a9f4244224661c3cca30e8c2d4f6f035a" name="a9f4244224661c3cca30e8c2d4f6f035a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4244224661c3cca30e8c2d4f6f035a">&#9670;&#160;</a></span>gen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 SplitMerge_LSS_SDDS::gen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel mutable">mutable</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mersenne Twister random number generator for sampling operations. </p>

</div>
</div>
<a id="a5b7e28f5bbaa1f121c422f5674bfc66d" name="a5b7e28f5bbaa1f121c422f5674bfc66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7e28f5bbaa1f121c422f5674bfc66d">&#9670;&#160;</a></span>idx_i</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::idx_i</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of first randomly chosen observation. </p>

</div>
</div>
<a id="ac78a6b05561a6fd865da7ffc8fc418e6" name="ac78a6b05561a6fd865da7ffc8fc418e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78a6b05561a6fd865da7ffc8fc418e6">&#9670;&#160;</a></span>idx_j</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SplitMerge_LSS_SDDS::idx_j</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of second randomly chosen observation. </p>

</div>
</div>
<a id="a8a553a998dad40546a0efddb30a19eca" name="a8a553a998dad40546a0efddb30a19eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a553a998dad40546a0efddb30a19eca">&#9670;&#160;</a></span>launch_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi SplitMerge_LSS_SDDS::launch_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch state for sequential allocation. </p>

</div>
</div>
<a id="ada77f2fce6d6778a9829447a663bf3c8" name="ada77f2fce6d6778a9829447a663bf3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada77f2fce6d6778a9829447a663bf3c8">&#9670;&#160;</a></span>log_merge_gibbs_prob</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SplitMerge_LSS_SDDS::log_merge_gibbs_prob = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log probability of generating current state via sequential allocation (merge direction) </p>

</div>
</div>
<a id="ae11d1391d015b667789491845f9a95e1" name="ae11d1391d015b667789491845f9a95e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11d1391d015b667789491845f9a95e1">&#9670;&#160;</a></span>log_split_gibbs_prob</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SplitMerge_LSS_SDDS::log_split_gibbs_prob = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log probability of generating current state via sequential allocation (split direction) </p>

</div>
</div>
<a id="a415513c7aa6969479e7c4eb3021203d5" name="a415513c7aa6969479e7c4eb3021203d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415513c7aa6969479e7c4eb3021203d5">&#9670;&#160;</a></span>original_allocations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi SplitMerge_LSS_SDDS::original_allocations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Original cluster assignments before move proposal. </p>

</div>
</div>
<a id="ab89d3b1669dc604e8eacb2ee938a93a0" name="ab89d3b1669dc604e8eacb2ee938a93a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89d3b1669dc604e8eacb2ee938a93a0">&#9670;&#160;</a></span>S</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi SplitMerge_LSS_SDDS::S</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices of observations in clusters ci and cj. </p>

</div>
</div>
<a id="aa067403728ed88f2b18980e4d0bb0379" name="aa067403728ed88f2b18980e4d0bb0379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa067403728ed88f2b18980e4d0bb0379">&#9670;&#160;</a></span>shuffle_bool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SplitMerge_LSS_SDDS::shuffle_bool = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to enable shuffle moves (Mena and Martinez, 2014) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/samplers/<a class="el" href="splitmerge__LSS__SDDS_8hpp_source.html">splitmerge_LSS_SDDS.hpp</a></li>
<li>src/samplers/<a class="el" href="splitmerge__LSS__SDDS_8cpp.html">splitmerge_LSS_SDDS.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSplitMerge__LSS__SDDS.html">SplitMerge_LSS_SDDS</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</body>
</html>
